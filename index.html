<!DOCTYPE html>
<html lang="en">
<head>
    <title>Segment Intersection</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./style/style.css">
</head>
<body>
    <canvas id="myCanvas"></canvas>
    <script>
        myCanvas.height = window.innerHeight;
        myCanvas.width = window.innerWidth;

        //Defining the points
        const A = { x: 200, y: 150 };
        const B = { x: 150, y: 250 };
        const C = { x: 50, y: 100 };
        const D = { x: 250, y: 200 };

        //Sketching the lines between the points
        const ctx = myCanvas.getContext('2d');

        // To try other angles of A-B using the mouse to try various other posibilities of the intersection
        let angle=0;
        // To allow moving the points using the mouse to try various other posibilities of the intersection
        const mouse = { x: 0, y: 0 };
        document.onmousemove = event => {
            mouse.x = event.x;
            mouse.y = event.y;
        }

        let t=50;
        animate();

        function animate(){

            const radius = 50;
            // A will be 50px above the mouse, B will be 50px below the mouse
            // Adding the sin and cos would make the points move in a circle => bottom is 0 when both A-B & C-D are parallel

            A.x = mouse.x+Math.cos(angle)*radius;
            A.y = mouse.y-Math.sin(angle)*radius;
            B.x = mouse.x-Math.cos(angle)*radius;
            B.y = mouse.y+Math.sin(angle)*radius;
            // While the angle values are changing in this way, and angles are all in radians, & the numbers are represented as floating point numbers with some number of digits with no full accuracy there, so the values will never be exactly 0, so the bottom will never be exactly 0, so the system will never break.
            angle += 0.02;

            ctx.clearRect(0,0,myCanvas.width,myCanvas.height);
            
            ctx.beginPath();
            ctx.strokeStyle = 'white';
            ctx.moveTo(A.x, A.y);
            ctx.lineTo(B.x, B.y);
            ctx.moveTo(C.x, C.y);
            ctx.lineTo(D.x, D.y);
            ctx.stroke();
    
            markPoints(A,"A");
            markPoints(B,"B");
            markPoints(C,"C");
            markPoints(D,"D");

            // Calculating the Intersection of the lines
            const I = getIntersection(A,B,C,D);
            markPoints(I,"I", true);
            
            // Value of the bottom will be available here and can be displayed over the canvas
            ctx.beginPath();
            // Drawing a rectangle in the middle of the canvas to display the value of the bottom, the rectangle will be on top of the canvas. The width of the rectangle will be the value of the bottom, so the rectangle will grow and shrink as the value of the bottom changes. Height is 10px.
            ctx.rect(myCanvas.width/2, 0, I.bottom/100, 10);    
            ctx.fill();        

            /* The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the
            browser calls a specified function to update an animation right before the next repaint. The method takes a callback as
            an argument to be invoked before the repaint.  */
            requestAnimationFrame(animate);
        }

        function lerp(A,B,t){ // A, B are points, t is the %
            return A+(B-A)*t; // if t is 1, the midpoint is B, if t is 0.5 or half, the midpoint is half away from A
        }

        function getIntersection(A,B,C,D){
            /*  The intersection points needs to satisfy these two equations on Linear Interpolation:
                Ix = Ax + (Bx-Ax)t = Cx + (Dx-Cx)u
                Iy = Ay + (By-Ay)t = Cy + (Dy-Cy)u
                where t and u are the interpolation parameters, and 2 distinct var are used here as same t does not work as the lines may/do not have the same .
                
                Ax + (Bx-Ax)t = Cx + (Dx-Cx)u =>  (Ax-Cx) + (Bx-Ax)t = (Dx-Cx)u 
                => [(Ax-Cx) + (Bx-Ax)t]/(Dx-Cx) = u : but there is a problem, as Dx-Cx might be 0
                
                Ay + (By-Ay)t = Cy + (Dy-Cy)u =>  (Ay-Cy) + (By-Ay)t = (Dy-Cy)u => *(Dx-Cx) 

                => (Ay-Cy)(Dx-Cx) + (By-Ay)(Dx-Cx)t = (Dy-Cy)(Dx-Cx)u

                => (Ay-Cy)(Dx-Cx) + (By-Ay)(Dx-Cx)t = (Dy-Cy)(Ax-Cx) + (Dy-Cy)(Bx-Ax)t |:| {ln:78} (Dx-Cx)u  = (Ax-Cx) + (Bx-Ax)t 
                => (Ay-Cy)(Dx-Cx) - (Dy-Cy)(Ax-Cx) = (Dy-Cy)(Bx-Ax)t - (Dx-Cx)(By-Ay)t


                t = (Ay-Cy)(Dx-Cx) - (Dy-Cy)(Ax-Cx) / (Dy-Cy)(Bx-Ax) - (Dx-Cx)(By-Ay)
                t = top / bottom

                A-B is straight, so trying out other angles may break the system(bottom = 0). So, to make sure that the system works all the time.
            */

            const top = (A.y-C.y)*(D.x-C.x) - (D.y-C.y)*(A.x-C.x);
            const bottom = (D.y-C.y)*(B.x-A.x) - (D.x-C.x)*(B.y-A.y);
            const t = top/bottom;
            //console.log("Checking if bottom is 0:\t", bottom);
            //linear interpolation is used to return the point of intersection(x,y), as A, B and t are available
            return { 
                x: lerp(A.x,B.x,t), 
                y: lerp(A.y,B.y,t),
                bottom 
            };
        }
        
        function markPoints(point,label, isRed){
            // Marking the points
            ctx.beginPath();
            // Arc as a circle around the point to mark it, with radius - 10px, 
            ctx.fillStyle=isRed?"green":"white";
            ctx.arc(point.x, point.y, 10, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle="black";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.font="bold 14px arial";
            ctx.fillText(label, point.x, point.y);
        }
    </script>
</body>
</html>